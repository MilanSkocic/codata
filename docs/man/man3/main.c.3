.TH "main.c" 3 "Fri Oct 28 2022" "Version 1.0" "Codata" \" -*- nroff -*-
.ad l
.nh
.SH NAME
main.c \- Source code generator for C and Fortran languages\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <ctype\&.h>\fP
.br
\fC#include 'config\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBC\fP   0"
.br
.ti -1c
.RI "#define \fBF90\fP   1"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBformat_names\fP (char *line, char *name, char *dname, int language)"
.br
.ti -1c
.RI "void \fBformat_values\fP (char *line, char *value, int language)"
.br
.ti -1c
.RI "void \fBformat_uncertainties\fP (char *line, char *uncertainty, int language)"
.br
.ti -1c
.RI "void \fBformat_units\fP (char *line, char *unit, int language)"
.br
.ti -1c
.RI "int \fBread_line\fP (FILE *f, char *buf)"
.br
.ti -1c
.RI "void \fBclean_line\fP (char *buf, size_t buffer_size)"
.br
.ti -1c
.RI "void \fBltrim\fP (char *buf, size_t buffer_size)"
.br
.ti -1c
.RI "int \fBis_blank_line\fP (char *buf, size_t buffer_size)"
.br
.ti -1c
.RI "char ** \fBget_table\fP (size_t rows, size_t line_buffer_size)"
.br
.ti -1c
.RI "void \fBfree_table\fP (char **table, size_t rows, size_t line_buffer_size)"
.br
.ti -1c
.RI "void \fBprint_table\fP (char **table, size_t rows, size_t line_buffer_size)"
.br
.ti -1c
.RI "void \fBinit_table\fP (char **table, size_t rows, size_t line_buffer_size)"
.br
.ti -1c
.RI "void \fBwrite_output\fP (FILE *codata, FILE *fcode, FILE *fheader, int language)"
.br
.ti -1c
.RI "int \fBmain\fP (int argc, char **argv)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const size_t \fBBUFFER_SIZE\fP = 256"
.br
.ti -1c
.RI "static const size_t \fBNAMES_SIZE\fP = 60"
.br
.ti -1c
.RI "static const size_t \fBVALUES_SIZE\fP = 25"
.br
.ti -1c
.RI "static const size_t \fBUNCERTAINTIES_SIZE\fP = 25"
.br
.ti -1c
.RI "static const size_t \fBUNITS_SIZE\fP = 25"
.br
.ti -1c
.RI "static const char \fBnewline\fP [2] = '\\n\\0'"
.br
.ti -1c
.RI "static const char \fBc_end\fP [2] = ';\\0'"
.br
.ti -1c
.RI "static const char \fBf90_end\fP [1] = '\\0'"
.br
.ti -1c
.RI "static const char \fBc_equal\fP [4] = ' = \\0'"
.br
.ti -1c
.RI "static const char \fBf90_equal\fP [4] = ' = \\0'"
.br
.ti -1c
.RI "static const char \fBc_comment\fP [3] = '//\\0'"
.br
.ti -1c
.RI "static const char \fBf90_comment\fP [3] = '!!\\0'"
.br
.ti -1c
.RI "static const char \fBc_doxy_inline_start\fP [] = '/**< '"
.br
.ti -1c
.RI "static const char \fBc_doxy_inline_end\fP [] = ' */'"
.br
.ti -1c
.RI "static const char \fBf_doxy_inline_start\fP [] = '!< '"
.br
.ti -1c
.RI "static const char \fBf_doxy_inline_end\fP [] = ' '"
.br
.ti -1c
.RI "static const char \fBc_doxy_start\fP [] = '/** \\n * @file\\n'"
.br
.ti -1c
.RI "static const char \fBc_doxy_middle\fP [] = ' * '"
.br
.ti -1c
.RI "static const char \fBc_doxy_end\fP [] = ' */\\n'"
.br
.ti -1c
.RI "static const char \fBf_doxy_start\fP [] = '!> \\n'"
.br
.ti -1c
.RI "static const char \fBf_doxy_middle\fP [] = '!! '"
.br
.ti -1c
.RI "static const char \fBf_doxy_end\fP [] = '!! \\n'"
.br
.ti -1c
.RI "static const char \fBc_doxy_example\fP [] = '@example example_in_c\&.c\\n'"
.br
.ti -1c
.RI "static const char \fBc_doxy_example_detail\fP [] = '@details How to us ccodata in c\&.\\n'"
.br
.ti -1c
.RI "static const char \fBf_doxy_example\fP [] = '@example example_in_fortran\&.f90\\n'"
.br
.ti -1c
.RI "static const char \fBf_doxy_example_detail\fP [] = '@details How to us ccodata in Fortran\&.\\n'"
.br
.ti -1c
.RI "static const char \fBc_type\fP [14] = 'const double \\0'"
.br
.ti -1c
.RI "static const char \fBf90_type\fP [30] = 'real(c_double), parameter :: \\0'"
.br
.ti -1c
.RI "static const char \fBc_header\fP [] = '#include \\'codata\&.h\\'\\0'"
.br
.ti -1c
.RI "static const char \fBf90_header\fP [49] = 'module codata\\nuse iso_c_binding\\nimplicit none\\0'"
.br
.ti -1c
.RI "static const char \fBc_footer\fP [1] = '\\0'"
.br
.ti -1c
.RI "static const char \fBf90_footer\fP [18] = 'end module codata\\0'"
.br
.ti -1c
.RI "static const char \fBcodata_path\fP [] = '\&./codata\&.txt'"
.br
.in -1c
.SH "Detailed Description"
.PP 
Source code generator for C and Fortran languages\&. 

The raw codata from http://physics.nist.gov/constants are converted into C and Fortran code\&. The generator generates:
.IP "\(bu" 2
an module for Fortran
.IP "\(bu" 2
and header and source files for C The generated files are then compiled into shared and static libraries\&. 
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define C   0"

.SS "#define F90   1"

.SH "Function Documentation"
.PP 
.SS "void clean_line (char * buf, size_t buffer_size)"

.SS "void format_names (char * line, char * name, char * dname, int language)"

.SS "void format_uncertainties (char * line, char * uncertainty, int language)"

.SS "void format_units (char * line, char * unit, int language)"

.SS "void format_values (char * line, char * value, int language)"

.SS "void free_table (char ** table, size_t rows, size_t line_buffer_size)"

.SS "char ** get_table (size_t rows, size_t line_buffer_size)"

.SS "void init_table (char ** table, size_t rows, size_t line_buffer_size)"

.SS "int is_blank_line (char * buf, size_t buffer_size)"

.SS "void ltrim (char * buf, size_t buffer_size)"

.SS "int main (int argc, char ** argv)"

.PP
\fBExamples\fP
.in +1c
\fBexample_in_c\&.c\fP\&.
.SS "void print_table (char ** table, size_t rows, size_t line_buffer_size)"

.SS "int read_line (FILE * f, char * buf)"

.SS "void write_output (FILE * codata, FILE * fcode, FILE * fheader, int language)"

.SH "Variable Documentation"
.PP 
.SS "const size_t BUFFER_SIZE = 256\fC [static]\fP"

.SS "const char c_comment[3] = '//\\0'\fC [static]\fP"

.SS "const char c_doxy_end[] = ' */\\n'\fC [static]\fP"

.SS "const char c_doxy_example[] = '@example example_in_c\&.c\\n'\fC [static]\fP"

.SS "const char c_doxy_example_detail[] = '@details How to us ccodata in c\&.\\n'\fC [static]\fP"

.SS "const char c_doxy_inline_end[] = ' */'\fC [static]\fP"

.SS "const char c_doxy_inline_start[] = '/**< '\fC [static]\fP"

.SS "const char c_doxy_middle[] = ' * '\fC [static]\fP"

.SS "const char c_doxy_start[] = '/** \\n * @file\\n'\fC [static]\fP"

.SS "const char c_end[2] = ';\\0'\fC [static]\fP"

.SS "const char c_equal[4] = ' = \\0'\fC [static]\fP"

.SS "const char c_footer[1] = '\\0'\fC [static]\fP"

.SS "const char c_header[] = '#include \\'codata\&.h\\'\\0'\fC [static]\fP"

.SS "const char c_type[14] = 'const double \\0'\fC [static]\fP"

.SS "const char codata_path[] = '\&./codata\&.txt'\fC [static]\fP"

.SS "const char f90_comment[3] = '!!\\0'\fC [static]\fP"

.SS "const char f90_end[1] = '\\0'\fC [static]\fP"

.SS "const char f90_equal[4] = ' = \\0'\fC [static]\fP"

.SS "const char f90_footer[18] = 'end module codata\\0'\fC [static]\fP"

.SS "const char f90_header[49] = 'module codata\\nuse iso_c_binding\\nimplicit none\\0'\fC [static]\fP"

.SS "const char f90_type[30] = 'real(c_double), parameter :: \\0'\fC [static]\fP"

.SS "const char f_doxy_end[] = '!! \\n'\fC [static]\fP"

.SS "const char f_doxy_example[] = '@example example_in_fortran\&.f90\\n'\fC [static]\fP"

.SS "const char f_doxy_example_detail[] = '@details How to us ccodata in Fortran\&.\\n'\fC [static]\fP"

.SS "const char f_doxy_inline_end[] = ' '\fC [static]\fP"

.SS "const char f_doxy_inline_start[] = '!< '\fC [static]\fP"

.SS "const char f_doxy_middle[] = '!! '\fC [static]\fP"

.SS "const char f_doxy_start[] = '!> \\n'\fC [static]\fP"

.SS "const size_t NAMES_SIZE = 60\fC [static]\fP"

.SS "const char newline[2] = '\\n\\0'\fC [static]\fP"

.SS "const size_t UNCERTAINTIES_SIZE = 25\fC [static]\fP"

.SS "const size_t UNITS_SIZE = 25\fC [static]\fP"

.SS "const size_t VALUES_SIZE = 25\fC [static]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for Codata from the source code\&.
